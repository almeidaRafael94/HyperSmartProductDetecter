
//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include "opencv2/bgsegm.hpp"
#include <opencv2/video.hpp>
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
using namespace cv;
using namespace std;
// Global variables
Mat frame; //current frame
Mat fgMaskMOG; //fg mask fg mask generated by MOG2 method
//Mat fgMaskMOG2;
Mat drawing;
Mat output;

Ptr<BackgroundSubtractor> pMOG;
//Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard; //input from keyboard
void help();
void processVideo(char* videoFilename);
Mat thresh_callback(Mat src, String mask_type );
void frameNumber(Mat img, VideoCapture capture);

void Erosion( int, void* );
void Dilation( int, void* );
Mat erosion_src, dilation_src, erosion_dst, dilation_dst;
Mat dilation_element, erosion_element;
int dilation_type, erosion_type;

int erosion_elem = 0;
int erosion_size = 0;
int dilation_elem = 0;
int dilation_size = 0;

Mat dst;
int thresh = 0;
int thresh_max = 255;
int max_thresh = 255;

int maxLinePosition = 426;
int linePosition = maxLinePosition/2;

RNG rng(12345);
Mat threshold_output;
vector<vector<Point> > contours;
vector<Vec4i> hierarchy;

// MORPH_RECT = 0
// MORPH_ELLIPSE = 1
// MORPH_CROSS = 2
int morph_elem = 0;

// Kernel size
int morph_size = 6;

int morph_operator = 0;

int const max_operator = 4;
int const max_elem = 2;
int const max_kernel_size = 21;

int poly = 1;
int maxPoly = 2;

int numberOfProducts = 0;

//get the frame number and write it on the current frame
void frameNumber(Mat img, VideoCapture capture)
{
    stringstream ss;
    rectangle(frame, cv::Point(10, 2), cv::Point(100,20),cv ::Scalar(255,255,255), -1);
    ss << capture.get(CAP_PROP_POS_FRAMES);
    string frameNumberString = ss.str();
    putText(img, frameNumberString.c_str(), cv::Point(15, 15),
            FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
}

/**  @function Erosion  */
void Erosion( int, void* )
{
  if( erosion_elem == 0 ){ erosion_type = MORPH_RECT; }
  else if( erosion_elem == 1 ){ erosion_type = MORPH_CROSS; }
  else if( erosion_elem == 2) { erosion_type = MORPH_ELLIPSE; }

  erosion_element = getStructuringElement( erosion_type,
                       Size( 2*erosion_size + 1, 2*erosion_size+1 ),
                       Point( erosion_size, erosion_size ) );
}

void Dilation( int, void* )
{
  if( dilation_elem == 0 ){ dilation_type = MORPH_RECT; }
  else if( dilation_elem == 1 ){ dilation_type = MORPH_CROSS; }
  else if( dilation_elem == 2) { dilation_type = MORPH_ELLIPSE; }

  dilation_element = getStructuringElement( dilation_type,
                       Size( 2*dilation_size + 1, 2*dilation_size+1 ),
                       Point( dilation_size, dilation_size ) );
}

void help()
{
    cout
    << "--------------------------------------------------------------------------" << endl
    << "This program shows how to use background subtraction methods provided by "  << endl
    << " OpenCV. You can process both videos (-vid) and images (-img)."             << endl
                                                                                    << endl
    << "Usage:"                                                                     << endl
    << "./bs {-vid <video filename>}"                         << endl
    << "--------------------------------------------------------------------------" << endl
    << endl;
}

int main(int argc, char* argv[])
{
    //print help information
    help();
    //check for the input parameter correctness
    if(argc != 3) {
        cerr <<"Incorret input list" << endl;
        cerr <<"exiting..." << endl;
        return EXIT_FAILURE;
    }

    //create GUI windows
    //create Background Subtractor objects
    pMOG = bgsegm::createBackgroundSubtractorMOG(); //MOG approach
    //pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach

    /* EROSION AND DILATION Trackbars
    /// Create windows
    namedWindow( "Erosion Demo", WINDOW_AUTOSIZE );
    namedWindow( "Dilation Demo", WINDOW_AUTOSIZE );
    namedWindow( "morphologyEx", WINDOW_AUTOSIZE );

    /// Create Erosion Trackbar
    createTrackbar( "Element:\n 0: Rect \n 1: Cross \n 2: Ellipse", "Erosion Demo", &erosion_elem, max_elem,Erosion );
    createTrackbar( "Kernel size:\n 2n +1", "Erosion Demo",&erosion_size, max_kernel_size,Erosion );

    /// Create Dilation Trackbar
    createTrackbar( "Element:\n 0: Rect \n 1: Cross \n 2: Ellipse", "Dilation Demo",&dilation_elem, max_elem,Dilation );
    createTrackbar( "Kernel size:\n 2n +1", "Dilation Demo",&dilation_size, max_kernel_size,Dilation );
    */

    namedWindow( "Products Detector", WINDOW_AUTOSIZE );


    /// Create morphologyEx Trackbar
    /// Uncomment to use

    //createTrackbar( "Morphological elem: 0:Rect  1:Cross  2:Ellipse", "Products Detector",&morph_elem, max_elem);
    //createTrackbar( "Morphological operator: ", "Products Detector",&morph_operator, max_operator);
    //createTrackbar( "Morphological kernel size:", "Products Detector",&morph_size, max_kernel_size);
    //createTrackbar( "Min Threshold", "Products Detector",&thresh, max_thresh);
    //createTrackbar( "Max Threshold", "Products Detector",&thresh_max, max_thresh);
    createTrackbar( "Line position", "Products Detector",&linePosition, maxLinePosition);
    createTrackbar( "Draw", "Products Detector",&poly, maxPoly);

    // Insert number of frame on image
    //frameNumber(fgMaskMOG, capture);

    if(strcmp(argv[1], "-vid") == 0) 
    {
        //input data coming from a video
        processVideo(argv[2]);
        cout << numberOfProducts << endl;

    }
    else {
        //error in reading input parameters
        cerr <<"Please, check the input parameters." << endl;
        cerr <<"Exiting..." << endl;
        return EXIT_FAILURE;
    }
    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}

void processVideo(char* videoFilename) {
    //create the capture object
    VideoCapture capture(videoFilename);
    if(!capture.isOpened()){
        //error in opening the video input
        cerr << "Unable to open video file: " << videoFilename << endl;
        exit(EXIT_FAILURE);
    }

    //read input data. ESC or 'q' for quitting
    while( (char)keyboard != 'q' && (char)keyboard != 27 ){
        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            return;
            //exit(EXIT_FAILURE);
        }

        //Resize image
        //cv::resize(frame, frame, cv::Size(), 0.8, 0.8);

        //update the background model
        pMOG->apply(frame, fgMaskMOG);
        //pMOG2->apply(frame, fgMaskMOG2);

        if(!fgMaskMOG.empty())
        {
        	drawing = thresh_callback(fgMaskMOG, "mog1");
          // Add product rectangles detected to original frame
			    add(drawing,frame,drawing);
      		imshow("Products Detector", drawing); //aqui
        } 

        /*
      	if(!fgMaskMOG2.empty())
        {
          Mat drawing = thresh_callback(fgMaskMOG2, "mog2");
          Mat output;
  		
          add(drawing,originalFrame,output);
        	//imshow("Products Detector2", output); aqui
      	}
    	  */

        //get the input from the keyboard
        keyboard = waitKey( 30 );
    }
    //delete capture object
    capture.release();
}
/** @function thresh_callback */
Mat thresh_callback(Mat src, String mask_type)
{		
  //Mat element = getStructuringElement( morph_elem, Size( 2*morph_size + 1, 2*morph_size+1 ), Point( morph_size, morph_size ) );
  //morphologyEx( src, dst, operation, element );

  Mat element = getStructuringElement(morph_elem,Size(morph_size, morph_size));
  morphologyEx( src, dst, morph_operator, element, Point(-1,-1));
  //imshow("morphologyEx", dst);

  /// Detect edges using Threshold
  threshold( dst, threshold_output, thresh, thresh_max, THRESH_BINARY );
  /// Find contours
  findContours( threshold_output, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );

  /// Find the rotated rectangles and ellipses for each contour
  vector<RotatedRect> minRect( contours.size() );
  vector<RotatedRect> minEllipse( contours.size() );

  ///First Approach -> minAreaRect
  for( int i = 0; i < contours.size(); i++ )
  { 
       if( contours[i].size() > 100 )
       { 
          minRect[i] = minAreaRect( Mat(contours[i]) );
          minEllipse[i] = fitEllipse( Mat(contours[i]) ); 
       }
  }

   /// Draw contours + rotated rects + ellipses
  Mat drawing = Mat::zeros( threshold_output.size(), CV_8UC3 );
  line(drawing, Point(0, maxLinePosition-linePosition), Point(drawing.cols, maxLinePosition-linePosition), Scalar(0,255,0), 3);

  for( int i = 0; i< contours.size(); i++ )
  {
      Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );
      
      if(poly == 0)
      {
          //contour
          drawContours( drawing, contours, i, color, 2, 8, vector<Vec4i>(), 0, Point() );
      }
      else if(poly == 1)
      {
          // ellipse
          ellipse( drawing, minEllipse[i], color, 2, 8 );

          if (minEllipse[i].center.y < ((maxLinePosition-linePosition) + 1) && minEllipse[i].center.y > ((maxLinePosition-linePosition) - 1))
          {
            circle(drawing,minEllipse[i].center,10,Scalar(0,0,255), CV_FILLED);
            numberOfProducts ++;
          }  
          else
          {
             circle(drawing,minEllipse[i].center,5,Scalar(0,255,0));
          }
      } 
      else
      {
          // rotated rectangle
          Point2f rect_points[4]; 
          minRect[i].points( rect_points);
          for( int j = 0; j < 4; j++ )
          {
            if(norm(rect_points[j] - rect_points[(j+1)%4]) > 30 )
            {
              // min rectangle
              line( drawing, rect_points[j], rect_points[(j+1)%4], color, 2, 8 );
            }
          }
      }
  }
  
   /* Second approach
   /// Find the convex hull object for each contour
   vector<vector<Point> >hull( contours.size() );
   for( int i = 0; i < contours.size(); i++ )
   {  
      convexHull( Mat(contours[i]), hull[i], false); 
   }

   /// Draw contours + hull results
   Mat drawing = Mat::zeros( threshold_output.size(), CV_8UC3 );
   for( int i = 0; i< contours.size(); i++ )
      {
        Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );
        drawContours( drawing, contours, i, color, 2, 8, vector<Vec4i>(), 0, Point() );
        //drawContours( drawing, hull, i, color, 1, 8, vector<Vec4i>(), 0, Point() );
      }
  */

  /*
	/// Draw polygonal contour + bonding rects + circles
	Mat drawing = Mat::zeros( threshold_output.size(), CV_8UC3 );


	for( int i = 0; i< contours.size(); i++ )
	 {

	   Scalar color = Scalar(rng.uniform(0,255), rng.uniform(0, 255), rng.uniform(0, 255));
	   //Scalar color = Scalar( 0, 255, 0 );
	   //drawContours( drawing, contours_poly, i, color, 1, 8, vector<Vec4i>(), 0, Point() );
	  if ( ((boundRect[i].width * boundRect[i].height) > 1000) )           
		    {
			     rectangle( drawing, boundRect[i].tl(), boundRect[i].br(), color, 2, 8, 0 );
           numberOfProducts ++;
		    }
	  }
  */

	return drawing;
}