
//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include "opencv2/bgsegm.hpp"
#include <opencv2/video.hpp>
#include "opencv2/opencv.hpp"
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
using namespace cv;
using namespace std;
// Global variables
Mat frame; //current frame
Mat fgMaskMOG; //fg mask fg mask generated by MOG2 method
//Mat fgMaskMOG2;
Mat drawing;
Mat output;

Ptr<BackgroundSubtractor> pMOG;
//Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard; //input from keyboard
void help();
void processVideo(char* videoFilename);
Mat thresh_callback(Mat src, String mask_type, Mat frame);
void getframeNumber(Mat img, VideoCapture capture);

void Erosion( int, void* );
void Dilation( int, void* );
Mat erosion_src, dilation_src, erosion_dst, dilation_dst;
Mat dilation_element, erosion_element;
int dilation_type, erosion_type;

int erosion_elem = 0;
int erosion_size = 3;
int dilation_elem = 0;
int dilation_size = 0;
Mat erode_element = getStructuringElement( MORPH_ELLIPSE,
                         Size( 2*erosion_size + 1, 2*erosion_size+1 ),
                         Point( erosion_size, erosion_size ) );
Mat dst;
int thresh = 0;
int thresh_max = 255;
int max_thresh = 255;

int columnsNumber = 640;
int maxLinePosition = 426;
int linePosition=100;

RNG rng(12345);
Mat threshold_output;
vector<vector<Point> > contours;
vector<Vec4i> hierarchy;

// MORPH_RECT = 0
// MORPH_ELLIPSE = 1
// MORPH_CROSS = 2
int morph_elem = 0;

// Kernel size
int morph_size = 6;

int morph_operator = 0;

int const max_operator = 4;
int const max_elem = 2;
int const max_kernel_size = 21;

int poly = 3;
int maxPoly = 3;

int numberOfProducts = 0;
int frameNumber = 0;
double percentageAvg = 0;
int percentage = 50;
int totalPointsInArea = 0;

Mat spliter, resultMatching;
void MatchingMethod(Mat);

cv::SimpleBlobDetector::Params params; 

//get the frame number and write it on the current frame
void getframeNumber(Mat img, VideoCapture capture)
{
    stringstream ss;
    rectangle(frame, cv::Point(10, 2), cv::Point(100,20),cv ::Scalar(255,255,255), -1);
    ss << capture.get(CAP_PROP_POS_FRAMES);
    string frameNumberString = ss.str();
    putText(img, frameNumberString.c_str(), cv::Point(15, 15),
            FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
}

/**  @function Erosion  */
void Erosion( int, void* )
{
  if( erosion_elem == 0 ){ erosion_type = MORPH_RECT; }
  else if( erosion_elem == 1 ){ erosion_type = MORPH_CROSS; }
  else if( erosion_elem == 2) { erosion_type = MORPH_ELLIPSE; }

  erosion_element = getStructuringElement( erosion_type,
                       Size( 2*erosion_size + 1, 2*erosion_size+1 ),
                       Point( erosion_size, erosion_size ) );
}

void Dilation( int, void* )
{
  if( dilation_elem == 0 ){ dilation_type = MORPH_RECT; }
  else if( dilation_elem == 1 ){ dilation_type = MORPH_CROSS; }
  else if( dilation_elem == 2) { dilation_type = MORPH_ELLIPSE; }

  dilation_element = getStructuringElement( dilation_type,
                       Size( 2*dilation_size + 1, 2*dilation_size+1 ),
                       Point( dilation_size, dilation_size ) );
}

void help()
{
    cout
    << "--------------------------------------------------------------------------" << endl
    << "This program shows how to use background subtraction methods provided by "  << endl
    << " OpenCV. You can process both videos (-vid) and images (-img)."             << endl
                                                                                    << endl
    << "Usage:"                                                                     << endl
    << "./bs {-vid <video filename>}"                         << endl
    << "--------------------------------------------------------------------------" << endl
    << endl;
}

int main(int argc, char* argv[])
{
    
   
    //print help information
    help();
    //check for the input parameter correctness
    if(argc != 3) {
        cerr <<"Incorret input list" << endl;
        cerr <<"exiting..." << endl;
        return EXIT_FAILURE;
    }

    spliter = imread("slit.png");

    // Create windows
    namedWindow( "Template matching result", WINDOW_AUTOSIZE );

    //create GUI windows
    //create Background Subtractor objects
    pMOG = bgsegm::createBackgroundSubtractorMOG(); //MOG approach
    //pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach

    /* EROSION AND DILATION Trackbars
    /// Create windows
    namedWindow( "Erosion Demo", WINDOW_AUTOSIZE );
    namedWindow( "Dilation Demo", WINDOW_AUTOSIZE );
    namedWindow( "morphologyEx", WINDOW_AUTOSIZE );

    /// Create Erosion Trackbar
    createTrackbar( "Element:\n 0: Rect \n 1: Cross \n 2: Ellipse", "Erosion Demo", &erosion_elem, max_elem,Erosion );
    createTrackbar( "Kernel size:\n 2n +1", "Erosion Demo",&erosion_size, max_kernel_size,Erosion );

    /// Create Dilation Trackbar
    createTrackbar( "Element:\n 0: Rect \n 1: Cross \n 2: Ellipse", "Dilation Demo",&dilation_elem, max_elem,Dilation );
    createTrackbar( "Kernel size:\n 2n +1", "Dilation Demo",&dilation_size, max_kernel_size,Dilation );
    */

    namedWindow( "Products Detector", WINDOW_AUTOSIZE );


    /// Create morphologyEx Trackbar
    /// Uncomment to use

    //createTrackbar( "Morphological elem: 0:Rect  1:Cross  2:Ellipse", "Products Detector",&morph_elem, max_elem);
    //createTrackbar( "Morphological operator: ", "Products Detector",&morph_operator, max_operator);
    //createTrackbar( "Morphological kernel size:", "Products Detector",&morph_size, max_kernel_size);
    //createTrackbarr( "Min Threshold", "Products Detector",&thresh, max_thresh);
    //createTrackbar( "Max Threshold", "Products Detector",&thresh_max, max_thresh);
    //createTrackbar( "Line position", "Products Detector",&linePosition, maxLinePosition);
    createTrackbar( "Draw", "Products Detector",&poly, maxPoly);

    // Insert number of frame on image
    //frameNumber(fgMaskMOG, capture);
     
    // Show blobs
    //    imshow("keypoints", im_with_keypoints );
    //  waitKey(0);

    if(strcmp(argv[1], "-vid") == 0) 
    {
        //input data coming from a video
        processVideo(argv[2]);
        cout << numberOfProducts << endl;

    }
    else {
        //error in reading input parameters
        cerr <<"Please, check the input parameters." << endl;
        cerr <<"Exiting..." << endl;
        return EXIT_FAILURE;
    }
    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}

void processVideo(char* videoFilename) {
    //create the capture object
    VideoCapture capture(videoFilename);
    if(!capture.isOpened()){
        //error in opening the video input
        cerr << "Unable to open video file: " << videoFilename << endl;
        exit(EXIT_FAILURE);
    }

    //read input data. ESC or 'q' for quitting
    while( (char)keyboard != 'q' && (char)keyboard != 27 ){
        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            return;
            //exit(EXIT_FAILURE);
        }

        MatchingMethod(frame);

        frameNumber ++;

        // Draw detected blobs as red circles.
        // DrawMatchesFlags::DRAW_RICH_KEYPOINTS flag ensures the size of the circle corresponds to the size of blob
        
        //Resize image
        //cv::resize(frame, frame, cv::Size(), 0.8, 0.8);

        //update the background model
        Mat closing_output;
        cvtColor(frame, closing_output, CV_RGB2GRAY);
        erode( closing_output, closing_output, erode_element );
        dilate( closing_output, closing_output, erode_element );

        pMOG->apply(closing_output, fgMaskMOG,0);
        //pMOG2->apply(frame, fgMaskMOG2);

        if(!fgMaskMOG.empty())
        {
          drawing = thresh_callback(fgMaskMOG, "mog1", frame);
          // Add product rectangles detected to original frame
          add(drawing,frame,drawing);

          if(frameNumber == 0)
          {
            percentage = 50;
          }
          else if(frameNumber % 20 == 0)
          {
            percentage = (int)percentageAvg;
            putText(drawing, "UPDATE Direction", cv::Point(255, 15), FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,255));
            percentageAvg = 0;
          }

          char str[200];
          sprintf(str,"%d  Antennas direction %", percentage);
          putText(drawing, str, cv::Point(15, 15), FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,255));
          imshow("Products Detector", drawing); //aqui
        } 

        /*
        if(!fgMaskMOG2.empty())
        {
          Mat drawing = thresh_callback(fgMaskMOG2, "mog2");
          Mat output;
      
          add(drawing,originalFrame,output);
          //imshow("Products Detector2", output); aqui
        }
        */

        //get the input from the keyboard
        keyboard = waitKey( 30 );
    }
    //delete capture object
    capture.release();
}
/** @function thresh_callback */
Mat thresh_callback(Mat src, String mask_type, Mat frame)
{   
  //Mat element = getStructuringElement( morph_elem, Size( 2*morph_size + 1, 2*morph_size+1 ), Point( morph_size, morph_size ) );
  //morphologyEx( src, dst, operation, element );


 
  /*
  Mat element = getStructuringElement(morph_elem,Size(morph_size, morph_size));
  morphologyEx( src, dst, morph_operator, element, Point(-1,-1));

  namedWindow( "Contours", CV_WINDOW_AUTOSIZE );
  imshow( "Contours", dst ); 

  */
  
  /*
  Ptr<SimpleBlobDetector> detector = SimpleBlobDetector::create(params);
  // Detect blobs.
  std::vector<KeyPoint> keypoints;
  detector->detect(src, keypoints);


  Mat im_with_keypoints;
  drawKeypoints( src, keypoints, im_with_keypoints, Scalar(0,0,255), DrawMatchesFlags::DRAW_RICH_KEYPOINTS );
  

  //cerr <<  keypoints.size() << endl;

  namedWindow( "Contours", CV_WINDOW_AUTOSIZE );
  imshow( "Contours", im_with_keypoints );
  */
  /*
  //imshow("morphologyEx", dst);

  /// Detect edges using Threshold
  threshold( im_with_keypoints, threshold_output, thresh, thresh_max, THRESH_BINARY );
  /// Find contours
  findContours( threshold_output, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );
  
  */

  // apply filter
  Mat canny_output;

  Canny(src, canny_output, 180, 200, 3, true);

  blur(canny_output, canny_output, Size(11,11));

  findContours( canny_output, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );

  for (vector<vector<Point> >::iterator it = contours.begin(); it!=contours.end(); )
  {
    if (it->size()< 100)
        it=contours.erase(it);
    else
        ++it;
  }

  Mat mask = Mat::zeros(canny_output.rows, canny_output.cols, CV_8UC1);
  //drawContours(mask, contours, -1, Scalar(255), CV_FILLED);

  //imshow("Canny filter", mask);
  

  /// Get the moments
  vector<Moments> mu(contours.size() );
  for( int i = 0; i < contours.size(); i++ )
  { 
      mu[i] = moments( contours[i], false ); 
  }

  ///  Get the mass centers:
  vector<Point2f> mc( contours.size() );

  for( int i = 0; i < contours.size(); i++ )
  {
    mc[i] = Point2f( mu[i].m10/mu[i].m00 , mu[i].m01/mu[i].m00 );
  }

  //threshold( src, threshold_output, thresh, thresh_max, THRESH_BINARY );

  /// Find contours
  //findContours( threshold_output, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );

  /// Find the rotated rectangles and ellipses for each contour
  vector<RotatedRect> minRect( contours.size() );
  vector<RotatedRect> minEllipse( contours.size() );
  vector<Rect> boundRect( contours.size() );
  vector<vector<Point> > contours_poly( contours.size() );
  vector<Point> approxShape;

  ///First Approach -> minAreaRect
  for( int i = 0; i < contours.size(); i++ )
  { 
       if( contours[i].size() > 100 )
       { 
          minRect[i] = minAreaRect( Mat(contours[i]) );
          minEllipse[i] = fitEllipse( Mat(contours[i]) ); 
       }
  }

   /// Draw contours + rotated rects + ellipses
  Mat drawing = Mat::zeros( canny_output.size(), CV_8UC3 );
  line(drawing, Point(0, maxLinePosition-linePosition), Point(drawing.cols, maxLinePosition-linePosition), Scalar(0,255,0), 3);

  line(drawing, Point(0, maxLinePosition*0.6), Point(drawing.cols, maxLinePosition*0.6), Scalar(0,0,255), 3);
  line(drawing, Point(0, maxLinePosition*0.9), Point(drawing.cols, maxLinePosition*0.9), Scalar(0,0,255), 3);

  totalPointsInArea = 0;
  percentageAvg = 0;

  for( int i = 0; i< contours.size(); i++ )
  {
      //Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );
      Scalar green = Scalar(0,255,0);
      Scalar red = Scalar(0,0,255);
      Scalar blue = Scalar(255,255,0);
      
      if(mc[i].y > maxLinePosition*0.6 && mc[i].y < maxLinePosition*0.9)
      {
        totalPointsInArea ++;
        percentageAvg += mc[i].x;
      }

      if(poly == 0)
      {
        //contour
        //drawContours( drawing, contours, i, blue, CV_FILLED, 8, vector<Vec4i>(), 0, Point());
        drawContours( drawing, contours, i, blue, CV_FILLED, 8, hierarchy, 0, Point() );
        if (minEllipse[i].center.y < ((maxLinePosition-linePosition) + 1) && minEllipse[i].center.y > ((maxLinePosition-linePosition) - 1))
        {
          circle(drawing,minEllipse[i].center,10,Scalar(0,0,255), CV_FILLED);
          numberOfProducts ++;
        }  
        else
        {
           circle(drawing,minEllipse[i].center,5,Scalar(0,255,0));
        }
      }
      else if(poly == 1)
      {
          // ellipse
          ellipse( drawing, minEllipse[i], green, 2, 8 );

          if (minEllipse[i].center.y < ((maxLinePosition-linePosition) + 1) && minEllipse[i].center.y > ((maxLinePosition-linePosition) - 1))
          {
            circle(drawing,minEllipse[i].center,10,Scalar(0,0,255), CV_FILLED);
            numberOfProducts ++;
          }  
          else
          {
             circle(drawing,minEllipse[i].center,5,Scalar(0,255,0));
          }
      } 
      else if(poly == 2)
      {

        //approxPolyDP( Mat(contours[i]), contours_poly[i], 3, true );
        //boundRect[i] = boundingRect( Mat(contours_poly[i]) );
        //rectangle( drawing, boundRect[i].tl(), boundRect[i].br(), blue, CV_FILLED, 8, 0 );


          // rotated rectangle
       
          Point2f rect_points[4]; 
          minRect[i].points( rect_points);

          bool draw = true;
          for( int j = 0; j < 4; j++ )
          {
            if(norm(rect_points[j] - rect_points[(j+1)%4]) < 50 )
            {
              draw = false;
              break;
            }
          }

          if(draw)
          {
            for( int j = 0; j < 4; j++ )
            {
              line( drawing, rect_points[j], rect_points[(j+1)%4], blue, 2, 8 );
            }
          }
      }
      else
      {
          drawContours( drawing, contours, i, blue, CV_FILLED, 8, hierarchy, 0, Point() );

          if (mc[i].y < ((maxLinePosition-linePosition) + 2) && mc[i].y > ((maxLinePosition-linePosition) - 2))
          {
            circle( drawing, mc[i],10, green, -1, 8, 0 );
            numberOfProducts ++;
          }  
          else
          {
            circle( drawing, mc[i],10, red, -1, 8, 0 );
          }

          Point2f rect_points[4]; 
          minRect[i].points( rect_points);

          bool draw = true;
          for( int j = 0; j < 4; j++ )
          {
            if(norm(rect_points[j] - rect_points[(j+1)%4]) < 50 )
            {
              draw = false;
              break;
            }
          }

          if(draw)
          {
            for( int j = 0; j < 4; j++ )
            {
              line( drawing, rect_points[j], rect_points[(j+1)%4], blue, 2, 8 );
            }
          }
      }
  }
  percentageAvg = percentageAvg/totalPointsInArea;
  namedWindow( "Mask", WINDOW_AUTOSIZE );
  imshow("Mask", drawing);
  
   /* Second approach
   /// Find the convex hull object for each contour
   vector<vector<Point> >hull( contours.size() );
   for( int i = 0; i < contours.size(); i++ )
   {  
      convexHull( Mat(contours[i]), hull[i], false); 
   }

   /// Draw contours + hull results
   Mat drawing = Mat::zeros( threshold_output.size(), CV_8UC3 );
   for( int i = 0; i< contours.size(); i++ )
      {
        Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );
        drawContours( drawing, contours, i, color, 2, 8, vector<Vec4i>(), 0, Point() );
        //drawContours( drawing, hull, i, color, 1, 8, vector<Vec4i>(), 0, Point() );
      }
  */

  /*
  /// Draw polygonal contour + bonding rects + circles
  Mat drawing = Mat::zeros( threshold_output.size(), CV_8UC3 );


  for( int i = 0; i< contours.size(); i++ )
   {

     Scalar color = Scalar(rng.uniform(0,255), rng.uniform(0, 255), rng.uniform(0, 255));
     //Scalar color = Scalar( 0, 255, 0 );
     //drawContours( drawing, contours_poly, i, color, 1, 8, vector<Vec4i>(), 0, Point() );
    if ( ((boundRect[i].width * boundRect[i].height) > 1000) )           
        {
           rectangle( drawing, boundRect[i].tl(), boundRect[i].br(), color, 2, 8, 0 );
           numberOfProducts ++;
        }
    }
  */

  return drawing;
}

void MatchingMethod(Mat frame)
{
  //thod: \n 0: SQDIFF \n 1: SQDIFF NORMED \n 2: TM CCORR \n 3: TM CCORR NORMED \n 4: TM COEFF \n 5: TM COEFF NORMED";
  int match_method = 2;

  Mat img_display;

  img_display = frame;

  // Create the result matrix
  int result_cols =  frame.cols - spliter.cols + 1;
  int result_rows = frame.rows - spliter.rows + 1;

  resultMatching.create( result_cols, result_rows, CV_32FC1 );

  /// Do the Matching and Normalize
  
  matchTemplate( frame, spliter, resultMatching, match_method );
  normalize( resultMatching, resultMatching, 0, 1, NORM_MINMAX, -1, Mat() );

  /// Localizing the best match with minMaxLoc
  double minVal; double maxVal; Point minLoc; Point maxLoc;
  Point matchLoc;

  minMaxLoc( resultMatching, &minVal, &maxVal, &minLoc, &maxLoc, Mat() );

  // For SQDIFF and SQDIFF_NORMED, the best matches are lower values. For all the other methods, the higher the better
  if( match_method  == CV_TM_SQDIFF || match_method == CV_TM_SQDIFF_NORMED )
    { matchLoc = minLoc; }
  else
    { matchLoc = maxLoc; }

  /// Show me what you got
  rectangle( img_display, matchLoc, Point( matchLoc.x + spliter.cols , matchLoc.y + spliter.rows ), Scalar::all(0), 2, 8, 0 );
  rectangle( resultMatching, matchLoc, Point( matchLoc.x + spliter.cols , matchLoc.y + spliter.rows ), Scalar::all(0), 2, 8, 0 );

  imshow( "Template matching result", resultMatching);

  return;
}